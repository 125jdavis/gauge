// Gauge Control Module Lite
// Jesse Davis
// 10/16/2023


///// LIBRARIES /////
#include <Adafruit_SSD1306.h>
#include <Adafruit_GFX.h>
#include <SPI.h>
//#include <Wire.h> //no I2C devices on this DCU
#include <mcp_can.h>
#include <Rotary.h>
#include <EEPROM.h>


///// DEFINE /////
#define OLED_RESET 4
#define CAN0_INT 18  // CAN Bus Interrupt pin

//Rotary Encoder switch
#define SWITCH 24 

// OLED Screen 1
#define SCREEN_W 128 // OLED display width, in pixels
#define SCREEN_H 32 // OLED display height, in pixels
#define MOSI  51    // SPI Master Out Pin
#define CLK   52    // SPI Clock Pin
#define OLED_DC_1    6
#define OLED_CS_1  5
#define OLED_RST_1 7

// OLED Screen 2
//#define SCREEN_W_2 128 // both screens are the same size, use only one width definition
//#define SCREEN_H_2 32 // both screens are the same size, use only one height definition
#define OLED_DC_2  28
#define OLED_CS_2  29
#define OLED_RST_2 26

///// INITIALIZE /////
MCP_CAN CAN0(53);     // Set CS to pin 53
Adafruit_SSD1306 display1(SCREEN_W, SCREEN_H, MOSI, CLK, OLED_DC_1, OLED_RST_1, OLED_CS_1);
Adafruit_SSD1306 display2(SCREEN_W, SCREEN_H, MOSI, CLK, OLED_DC_2, OLED_RST_2, OLED_CS_2);
Rotary rotary = Rotary(2, 3);

///// GLOBAL VARIABLES /////

// Analog inputs to Dash Control Module
// vBatt, on pin 0
float vBatt;
int filter_vBatt = 6; // out of 16, 16 = no filter
int analogPin0 = A0;

// fuel, on pin 3
float fuel;
int filter_fuel = 6; // out of 16, 16 = no filter
int analogPin3 = A3;

// therm, on pin 4
float therm;
float thermSensor;
int filter_therm = 50; // out of 100, 100 = no filter
int analogPin4 = A4;
int thermCAN;

// sensor a (baro), on pin 5
int baro;
int filter_baro = 6; // out of 16, 16 = no filter
int analogPin5 = A5;

// sensor b, on pin 6
float sensor_b;
int filter_b = 12;
int analogPin6 = A6;

// sensor c, on pin 7
float sensor_c;
int filter_c = 12;
int analogPin7 = A7;

// Rotary Encoder Variables
bool stateSW = 1;
bool lastStateSW = 1;
unsigned long lastStateChangeTime = 0;  // the last time the output pin was toggled
unsigned long debounceDelay = 50;       // the debounce time; increase if the output flickers
bool debounceFlag = 0;
bool button = 0;

// timers and refresh rates
int timer0, timer1, timer2, timer3;
//int dispMenuRate = 20;
int CANsendRate = 100;
int dispUpdateRate = 50;
int sensorUpdateRate = 100;
int splashTime = 1500; //how long should the splash screens show?

//Engine Parameters for Display
float oilPrs = 25;
float coolantTemp = 180;
float fuelPrs = 43;
float oilTemp = 200;
float fuelLvl = 75;
float battVolt = 12.6;

// CAN Bus variables
byte data[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
byte canMessageData [8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
unsigned long rxId;
unsigned char len = 0;
unsigned char rxBuf[8];
char msgString[128]; 

// Thermistor lookup table
const int thermTable_length = 6;
float thermTable_x[thermTable_length] = {0.23, 0.67, 1.43, 3.70, 4.63, 4.95};
float thermTable_l[thermTable_length] = { 150,  105,   75,   25,   -5,  -40};

// Fuel Level lookup table

// EEPROM Variables
byte clockOffsetAddress;  //EEPROM Address
int *input;               //this is a memory address
int output = 0;

// Menu Navigation Variables
byte menuLevel = 0;
char units = 'Imperial';
unsigned int nMenuLevel = 14; //This should be the number of menu items on the given level
byte dispArray[4] = { 1, 0, 0, 0 };  //should be written to EEPROM 0-3
unsigned int clockOffset;

///// IMAGES /////
// 'falcon_script', 128x32px
const unsigned char img_falcon_script [] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x1f, 0xc0, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x80, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x01, 0x80, 0x06, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x03, 0x00, 0x0c, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x02, 0x00, 0x19, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x62, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0xcc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xe0, 0x79, 0x98, 0x60, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xf9, 0xf9, 0x31, 0xf3, 0xe3, 0x38, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x01, 0xe3, 0x87, 0x33, 0x43, 0x27, 0xbf, 0xd8, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x0c, 0x63, 0x86, 0x6e, 0xf3, 0x10, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x08, 0xc3, 0x0c, 0x1c, 0x66, 0x30, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x11, 0x86, 0x38, 0x38, 0xcc, 0x60, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x13, 0x9e, 0x68, 0x69, 0x88, 0xc0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x1d, 0xe3, 0x8f, 0x8f, 0x18, 0xff, 0xc0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x06, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// '302_CID', 128x32px
const unsigned char img_302_CID [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x1e, 0x1e, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x3c, 0x3c, 
	0x1e, 0x1e, 0x1e, 0x00, 0x1f, 0xfe, 0x00, 0xff, 0xfc, 0x03, 0xff, 0xe0, 0x00, 0x3c, 0x3c, 0x3c, 
	0x1e, 0x1e, 0x1e, 0x00, 0x7f, 0xff, 0x81, 0xff, 0xfe, 0x0f, 0xff, 0xf8, 0x00, 0x3c, 0x3c, 0x3c, 
	0x1e, 0x1e, 0x1e, 0x00, 0xff, 0xff, 0xc3, 0xff, 0xff, 0x1f, 0xff, 0xfc, 0x00, 0x3c, 0x3c, 0x3c, 
	0x01, 0xe1, 0xe0, 0x01, 0xff, 0xff, 0xe3, 0xff, 0xff, 0x1f, 0xff, 0xfe, 0x00, 0x03, 0xc3, 0xc0, 
	0x01, 0xe1, 0xe0, 0x01, 0xfc, 0x0f, 0xe7, 0xf0, 0x3f, 0x9f, 0x00, 0x7e, 0x00, 0x03, 0xc3, 0xc0, 
	0x01, 0xe1, 0xe0, 0x01, 0xf8, 0x07, 0xc7, 0xe0, 0x1f, 0x80, 0x00, 0x7e, 0x00, 0x03, 0xc3, 0xc0, 
	0x01, 0xe1, 0xe0, 0x00, 0x00, 0x0f, 0x87, 0xe0, 0x1f, 0x81, 0xff, 0xfe, 0x00, 0x03, 0xc3, 0xc0, 
	0x1e, 0x1e, 0x1e, 0x00, 0x00, 0x7f, 0x87, 0xe0, 0x1f, 0x87, 0xff, 0xfc, 0x00, 0x3c, 0x3c, 0x3c, 
	0x1e, 0x1e, 0x1e, 0x00, 0x00, 0x7f, 0xc7, 0xe0, 0x1f, 0x8f, 0xff, 0xf8, 0x00, 0x3c, 0x3c, 0x3c, 
	0x1e, 0x1e, 0x1e, 0x00, 0x00, 0x0f, 0xe7, 0xe0, 0x1f, 0x8f, 0xff, 0xe0, 0x00, 0x3c, 0x3c, 0x3c, 
	0x1e, 0x1e, 0x1e, 0x01, 0xf8, 0x07, 0xe7, 0xe0, 0x1f, 0x9f, 0xc0, 0x00, 0x00, 0x3c, 0x3c, 0x3c, 
	0x01, 0xe1, 0xe0, 0x01, 0xfc, 0x0f, 0xe7, 0xf0, 0x3f, 0x9f, 0x80, 0x00, 0x00, 0x03, 0xc3, 0xc0, 
	0x01, 0xe1, 0xe0, 0x01, 0xff, 0xff, 0xe3, 0xff, 0xff, 0x1f, 0xff, 0xfe, 0x00, 0x03, 0xc3, 0xc0, 
	0x01, 0xe1, 0xe0, 0x00, 0xff, 0xff, 0xc3, 0xff, 0xff, 0x1f, 0xff, 0xfe, 0x00, 0x03, 0xc3, 0xc0, 
	0x01, 0xe1, 0xe0, 0x00, 0x7f, 0xff, 0x81, 0xff, 0xfe, 0x1f, 0xff, 0xfe, 0x00, 0x03, 0xc3, 0xc0, 
	0x1e, 0x1e, 0x1e, 0x00, 0x1f, 0xfe, 0x00, 0xff, 0xfc, 0x1f, 0xff, 0xfe, 0x00, 0x3c, 0x3c, 0x3c, 
	0x1e, 0x1e, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x3c, 0x3c, 
	0x1e, 0x1e, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x3c, 0x3c, 
	0x1e, 0x1e, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x3c, 0x3c, 
	0x01, 0xe1, 0xe0, 0x00, 0xe2, 0x4e, 0x23, 0x81, 0x24, 0x71, 0x27, 0x8c, 0x00, 0x03, 0xc3, 0xc0, 
	0x01, 0xe1, 0xe0, 0x01, 0x12, 0x49, 0x24, 0x41, 0x34, 0x89, 0x24, 0x10, 0x00, 0x03, 0xc3, 0xc0, 
	0x01, 0xe1, 0xe0, 0x01, 0x02, 0x4e, 0x24, 0x01, 0x34, 0x81, 0xe4, 0x0c, 0x00, 0x03, 0xc3, 0xc0, 
	0x01, 0xe1, 0xe0, 0x01, 0x02, 0x49, 0x24, 0x01, 0x2c, 0x81, 0x27, 0x82, 0x00, 0x03, 0xc3, 0xc0, 
	0x1e, 0x1e, 0x1e, 0x01, 0x12, 0x49, 0x24, 0x41, 0x2c, 0x89, 0x24, 0x12, 0x00, 0x3c, 0x3c, 0x3c, 
	0x1e, 0x1e, 0x1e, 0x00, 0xe1, 0x8e, 0x23, 0x81, 0x24, 0x71, 0x27, 0x8c, 0x00, 0x3c, 0x3c, 0x3c, 
	0x1e, 0x1e, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x3c, 0x3c, 
	0x1e, 0x1e, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x3c, 0x3c, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// '302V', 128x32px
const unsigned char img_302V [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xfe, 0x0f, 0xfc, 0x3f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0x1f, 0xfe, 0x7f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x03, 0x9c, 0x0e, 0x60, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x03, 0x98, 0x06, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x18, 0x06, 0x1f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x18, 0x06, 0x3f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x03, 0x98, 0x06, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x03, 0x9c, 0x0e, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xff, 0xff, 0xf3, 0xff, 0x1f, 0xfe, 0x7f, 0xfb, 0xff, 0xff, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0xf3, 0xc0, 0x01, 0xfe, 0x0f, 0xfc, 0x7f, 0xf8, 0x01, 0xe7, 0xe0, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0xfc, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x1f, 0xe0, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xff, 0x8f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0xff, 0x80, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x3f, 0xf1, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc7, 0xfe, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xfe, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x3f, 0xf8, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x01, 0xff, 0xc7, 0xc0, 0x00, 0x00, 0x01, 0xf1, 0xff, 0xc0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x7f, 0xf8, 0xfc, 0x00, 0x00, 0x1f, 0x8f, 0xff, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0x1f, 0xc0, 0x01, 0xfc, 0x7f, 0xf8, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xe3, 0xfc, 0x1f, 0xe3, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xfc, 0x3f, 0xfe, 0x1f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0x87, 0xf0, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xe1, 0xc3, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xf8, 0x0f, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xfe, 0x3f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 'Oil Pressure Icon', 40x32px
const unsigned char img_oilPrs [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x0f, 0xe0, 
	0x00, 0x00, 0x3f, 0xcf, 0xe0, 0x00, 0x38, 0x33, 0xe3, 0x80, 0x01, 0xfc, 0x30, 0xff, 0xf8, 0x1f, 
	0xf8, 0x38, 0x7f, 0xfc, 0xff, 0x80, 0x1e, 0x7f, 0xff, 0xff, 0x00, 0x07, 0xe0, 0x07, 0x8e, 0x08, 
	0x01, 0xe0, 0x00, 0x1e, 0x08, 0x00, 0x60, 0x00, 0x1c, 0x1c, 0x00, 0x60, 0x00, 0x38, 0x1c, 0x00, 
	0x60, 0x00, 0x70, 0x1c, 0x00, 0x7f, 0xff, 0xe0, 0x08, 0x00, 0x7f, 0xff, 0xc0, 0x00, 0x00, 0x7f, 
	0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 'Battery Icon', 38x32px
const unsigned char img_battVolt [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x00, 0x78, 0x00, 0x00, 0x78, 
	0x00, 0x78, 0x00, 0x00, 0x78, 0x00, 0x78, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xc0, 0x0f, 0xff, 0xff, 
	0xff, 0xc0, 0x0c, 0x00, 0x00, 0x00, 0xc0, 0x0c, 0x00, 0x00, 0x00, 0xc0, 0x0c, 0x00, 0x00, 0x30, 
	0xc0, 0x0c, 0x00, 0x00, 0x30, 0xc0, 0x0c, 0xfc, 0x00, 0xfc, 0xc0, 0x0c, 0xfc, 0x00, 0xfc, 0xc0, 
	0x0c, 0x00, 0x00, 0x30, 0xc0, 0x0c, 0x00, 0x00, 0x30, 0xc0, 0x0c, 0x00, 0x00, 0x00, 0xc0, 0x0c, 
	0x00, 0x00, 0x00, 0xc0, 0x0c, 0x00, 0x00, 0x00, 0xc0, 0x0c, 0x00, 0x00, 0x00, 0xc0, 0x0c, 0x00, 
	0x00, 0x00, 0xc0, 0x0f, 0xff, 0xff, 0xff, 0xc0, 0x0f, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 'Eng Temp Icon', 35x32px
const unsigned char img_coolantTemp [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 
	0xff, 0x80, 0x00, 0x00, 0x00, 0xff, 0x80, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0xf0, 
	0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0xff, 0x80, 0x00, 0x00, 0x00, 0xff, 0x80, 
	0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 
	0x00, 0x00, 0xff, 0x80, 0x00, 0x00, 0x00, 0xff, 0x80, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0xf0, 0x00, 0x00, 0x07, 0x81, 0xf8, 0x3c, 0x00, 0x1f, 0xf9, 0xf9, 0xff, 0x00, 0x18, 0x79, 
	0xf9, 0xc3, 0x00, 0x00, 0x01, 0xf8, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x0f, 0x0f, 0x0f, 0x0f, 0x00, 0x07, 0xff, 0xff, 0xfe, 0x00, 0x00, 0xf0, 0xf0, 0xf0, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

///// SETUP LOOP /////
void setup() {

  Serial.begin(115200); // open the serial port at 115200 bps:

    // Write dispArray values from initialization into EEPROM. this is not necessary code
  for (int i = 0; i < sizeof(dispArray); i++) {
    EEPROM.write(i, dispArray[i]);
  }
  
  // Initialize displays
  display1.begin(SSD1306_SWITCHCAPVCC);  // initialize with SPI
  display2.begin(SSD1306_SWITCHCAPVCC);  // initialize with SPI
  dispFalconScript(&display1);
  //delay(1000);  

  // Set up rotary switch interrupts
  attachInterrupt(0, rotate, CHANGE);
  attachInterrupt(1, rotate, CHANGE);
  
  //read display array from EEPROM and print to Serial Monitor. 
  //will need to change this code to actually control display screens instead of just serial print
  for (int i = 0; i < sizeof(dispArray); i++) {
    byte temp = EEPROM.read(i);
    Serial.println(temp);
  }

  //fetch last known clock offset from EEPROM
  clockOffset = EEPROM.read(clockOffsetAddress);  
  
  // Initialize MCP2515 running at 8MHz with a baudrate of 500kb/s and the masks and filters disabled.
  if(CAN0.begin(MCP_ANY, CAN_500KBPS, MCP_8MHZ) == CAN_OK) Serial.println("MCP2515 Initialized Successfully!");
  else Serial.println("Error Initializing MCP2515...");

  // Set up CAN interrupt pin
  pinMode(CAN0_INT, INPUT); 
  CAN0.setMode(MCP_NORMAL);   // Change to normal mode to allow messages to be transmitted

  //do nothing until splash screen timer runs out
  while (millis() < splashTime){
  }

}



///// MAIN LOOP /////
void loop() {
    
  //read analog voltage and get filtered value
  //fuel = readSensorFloat(analogPin3,fuel,filter_fuel);
  if (millis() - timer3 > sensorUpdateRate) {
    thermSensor = readThermSensor(analogPin4, thermSensor, filter_therm);
    therm = curveLookup(thermSensor, thermTable_x, thermTable_l, thermTable_length);
    thermCAN = therm*10;
    //Serial.print("sensor: ");
    //Serial.print(thermSensor);
    
    Serial.print("Therm: ");
    Serial.print(therm);
    Serial.print(", ");
    Serial.print("Baro: ");
    Serial.println(baro);

    baro = read30PSIAsensor(analogPin5,baro,filter_baro);  
    timer3 = millis();
  }

  sensor_b = readSensor(analogPin6,sensor_b,filter_b); 

  sensor_c = readSensor(analogPin7,sensor_c,filter_c); 


  // //display update timer
  // if (millis() - timer1 > dispUpdateRate) {  
  //   timer1 = millis();        // reset timer1       
  //   dispUpdate();             // update OLED display
  //   timer1 = millis();
  // }

  //Send CAN messages at specified rate
  if (millis() - timer2 > CANsendRate) {  
    timer2 = millis();        // reset timer1       
    //sendCAN_200(sensor_a);
    //sendCAN_201(sensor_b);       
    //sendCAN_202(sensor_c);
    sendCAN_203(thermCAN, fuel, baro, 1000);
    timer2 = millis();
  }

  //Read CAN messages as they come in
  if(!digitalRead(CAN0_INT)){     // If CAN0_INT pin is low, read receive buffer
    receiveCAN ();
    parseCAN( rxId, rxBuf);
  }
}





///// ALL FUNCTIONS /////

////// SENSOR READING FUNCTIONS ///// 
// Generic Sensor reader - reads, re-maps, and filters analog input values
int readSensor(int inputPin, int oldVal, int filt)  // read voltage, map to 0-5v, and filter
{
    int raw = analogRead (inputPin);
    int newVal = map( raw, 0, 1023, 0, 500);  
    int filtVal = ((newVal*filt) + (oldVal*(16-filt)))>>4;
    return filtVal; 
}

// Reads 30 PSI Absolute Sensor
int read30PSIAsensor(int inputPin, int oldVal, int filt)  // read voltage, map to 0-30 PSIA, and filter
{
    int raw = analogRead (inputPin);
    int newVal = map( raw, 102, 921, 0, 2068);  
    int filtVal = ((newVal*filt) + (oldVal*(16-filt)))>>4;
    return filtVal; 
}

// Reads GM CLT/IAT Thermistor
float readThermSensor(int inputPin, float oldVal, int filt)  // read voltage, map to -40-150 deg C, and filter
{
    int raw = analogRead (inputPin);
    float newVal = map( raw, 0, 1023, 0, 500)*0.01; 
    float filtVal = ((newVal*filt) + (oldVal*(100-filt)))*0.01;
    return filtVal; 
}

// Generic Curve Lookup
float curveLookup(float input, float brkpts[], float curve[], int curveLength){
  int index = 1;

  //find input's position within the breakpoints
  for (int i = 0; i <= curveLength-1; i++){
    if (input < brkpts[0]){
      float output = curve[0];
      return output;
    } 
    else if (input <= brkpts[i+1]){
      index = i+1;
      break;
    } 
    else if (input > brkpts[curveLength-1]){
      float output = curve[curveLength-1];
      return output;
    }
  } 

  // interpolation
  float x1 = brkpts[index];
  float x0 = brkpts[index-1];
  float y1 = curve[index];
  float y0 = curve[index-1];
  
  float output = (((y1-y0)/(x1-x0))*(input-x0))+y0;
  return output;
}


///// DISPLAY AND NAVIGATION FUNCTIONS /////
// Reads Encoder Switch and debounces
void swRead() {       
  stateSW = digitalRead(SWITCH);            // read the digital input pin
  int stateChange = stateSW - lastStateSW;  // calculate state change value

  if ((millis() - lastStateChangeTime) > debounceDelay) {
    debounceFlag = 0;  // flag will block state change if debounce time has not elapsed
  }

  if (stateChange < 0 && debounceFlag == 0) {  //if state change negative, button has been presed
    lastStateChangeTime = millis();            // reset the debouncing timer
    debounceFlag = 1;                          // set flag to block button bounce
  } else if (stateChange > 0 && debounceFlag == 0) {
    lastStateChangeTime = millis();    // reset the debouncing timer
    debounceFlag = 1;                  // set flag to block button bounce
    button = 1;
  } else if (stateChange = 0) {  // if state change = 0, nothing has happened
  }

  lastStateSW = stateSW;  // saves current switch state for next time
}

// General Encoder Incrementer for menu navigation 
void rotate() {
  //void rotate() {
  unsigned char result = rotary.process();
  if (result == DIR_CW) {
    if (dispArray[menuLevel] == nMenuLevel) dispArray[menuLevel] = 0; else dispArray[menuLevel]++;  // increment up one within range given for current menu level
  } else if (result == DIR_CCW) {
    if (dispArray[menuLevel] == 0l) dispArray[menuLevel] = nMenuLevel; else dispArray[menuLevel]--;  // increment down one within range given for current menu level
  }
}

// Controls display and menu navigation
void dispMenu() {
  switch (dispArray[0]) {  // Level 0
    case 1:                //dispArray {1 0 0 0} Oil Pressure
      if (menuLevel == 0 && button == 1) {  //if button is pressed, go down one level
        goToLevel0();
      }
      Serial.println("Oil Pressure");
      dispOilPrs(&display1);
      break;
    
    case 2:                //dispArray {2 0 0 0} Coolant Temp
      if (menuLevel == 0 && button == 1) {  //if button is pressed, do nothing
        goToLevel0();
      }
      Serial.println("Coolant Temp");
      dispCoolantTemp(&display1);
      break;
    
    case 3:                //dispArray {3 0 0 0} Oil Temp
      if (menuLevel == 0 && button == 1) {  //if button is pressed, do nothing
        goToLevel0();      }
      Serial.println("Oil Temp");
      dispOilTemp(&display1);
      break;
    
    case 4:                //dispArray {4 0 0 0} Fuel Level
      if (menuLevel == 0 && button == 1) {  //if button is pressed, do nothing
        goToLevel0();
      }
      Serial.println("Fuel Level");
      dispFuelLvl(&display1);
      break;
    
    case 5:                //dispArray {5 0 0 0} Odometer
      if (menuLevel == 0 && button == 1) {  //if button is pressed, do nothing
        goToLevel0(); 
      }
      Serial.println("Odometer");
      dispRectangle(&display1);
      break;    
    
    case 6:                //dispArray {6 0 0 0} Speed
      if (menuLevel == 0 && button == 1) {  //if button is pressed, do nothing
        goToLevel0();
      }
      Serial.println("Speed");
      dispOilPrsGfx(&display1);
      break;  
    
    case 7:                //dispArray {7 0 0 0} RPM
      if (menuLevel == 0 && button == 1) {  //if button is pressed, do nothing
        goToLevel0();
      }
      Serial.println("RPM");
      dispCoolantTempGfx(&display1);
      break;  
    
    case 8:                //dispArray {8 0 0 0} Ignition Timing
      if (menuLevel == 0 && button == 1) {  //if button is pressed, do nothing
        goToLevel0();
      }
      Serial.println("ignition timing");
      dispBattVoltGfx(&display1);
      break;
    
    case 9:                //dispArray {9 0 0 0} AFR
      if (menuLevel == 0 && button == 1) {  //if button is pressed, do nothing
        goToLevel0();
      }
      Serial.println("AFR");
      break;  
    case 10:               //dispArray {10 0 0 0} Fuel Pressure
      if (menuLevel == 0 && button == 1) {  //if button is pressed, do nothing
        goToLevel0();
      }
      Serial.println("Fuel Pressure");
      break;  

    case 11:               //dispArray {11 0 0 0} Fuel Composition
      if (menuLevel == 0 && button == 1) {  //if button is pressed, do nothing
        goToLevel0();
      }
      Serial.println("ethanol %");
      break;  
    
    case 12:               //dispArray {12 0 0 0} Clock
      if (menuLevel == 0 && button == 1) {  //if button is pressed, do nothing
        goToLevel0();
      }
      Serial.println("Clock");
      break;  
    
    case 13:               //dispArray {13 0 0 0} Battery Voltage
      if (menuLevel == 0 && button == 1) {  //if button is pressed, do nothing
        goToLevel0();
      }
      Serial.println("batt voltage");
      break;  
    
    case 14:               //dispArray {14 0 0 0} Falcon Script
      if (menuLevel == 0 && button == 1) {  //if button is pressed, do nothing
        goToLevel0();
      }
      Serial.println("falcon Script");
      dispFalconScript(&display1);
      break;  

    case 0:                //dispArray {0 0 0 0} Settings // ALWAYS LAST SCREEN, ALWAYS CASE 0 //

      if (menuLevel == 0 && button == 1) {  //if button is pressed, do nothing
        button = 0;
        menuLevel = 1;
        nMenuLevel = 2 ;
      } 
      else if (menuLevel == 0) {  //if no button is pressed, display settings
        Serial.println("settings");
      } 
      else {  // proceed to Level 0 screen 3 deeper levels

        switch (dispArray[1]) {
          case 0: //Select display units                  dispArray {0 0 0 0}
            if (menuLevel == 1 && button == 1) {
              button = 0;
              menuLevel = 2;
              nMenuLevel = 1;
            } else if (menuLevel == 1) {
              Serial.println("Units");
            } else {
              switch (dispArray[2]) {
                case 0:         // Imperial Units
                  Serial.println("Imperial");
                  units = 'Imperial';
                  if (button == 1) {
                    // save this setting to the EEPROM
                    goToLevel0();
                  }
                  break;
                case 1:         // Metric Units
                  Serial.println("Metric");
                  units = 'Metric';
                  if (button == 1) {
                    // save this setting to the EEPROM
                    goToLevel0();
                  }
                  break;
              }
            }
            break;
          
          case 1: //Clock Offset for modifying from GMT   dispArray {0 1 0 0}
            if (menuLevel == 1 && button == 1) {
              button = 0;
              menuLevel = 2;

            } else if (menuLevel == 1) {
              Serial.println("ClockOffset");
            } else {
              if (button == 1) {
                button = 0;
                dispArray[0] = 0;
                dispArray[1] = 0;
                dispArray[2] = 0;
                menuLevel = 0;
                nMenuLevel = 4;
                detachInterrupt(0);
                detachInterrupt(1);
                attachInterrupt(0, rotate, CHANGE);
                attachInterrupt(1, rotate, CHANGE);
                EEPROM.write(clockOffset, clockOffsetAddress);
              } else {
                
                //Need code here to make the rotary encoder change the offset value
                detachInterrupt(0);
                detachInterrupt(1);
                attachInterrupt(0, incrementOffset, CHANGE);
                attachInterrupt(1, incrementOffset, CHANGE);


                Serial.print("clock Offset: ");
                Serial.println(clockOffset);
              }
            }
            break;
          
          case 2: // Exit from settings,                  dispArray {0 2 0 0}
            Serial.println("Exit");
            if (button == 1) {
                    goToLevel0();
            }
            break;
        }
        break;
      }
  }
}

// Navigation subfunction
void goToLevel0(void){
  button = 0;
  dispArray[0] = 0;
  dispArray[1] = 0;
  dispArray[2] = 0;
  menuLevel = 0;
  nMenuLevel = 14;
}

// Increments Clock Offset
void incrementOffset() {
  //void rotate() {
  unsigned char result = rotary.process();
  if (result == DIR_CW) {
    if (clockOffset == 23) clockOffset = 0; else clockOffset++; // increment up one within range of 0-23
  } else if (result == DIR_CCW) {
    if(clockOffset == 0) clockOffset = 23; else clockOffset--;// increment down one within range of 0-23
  }
}

// void dispUpdate()   // Send voltage value to OLED display MAYBE NOT NEEDED
// {

//     display.setTextColor(WHITE); 
//     display.clearDisplay();             //clear buffer
//     display.setTextSize(2);             // text size
//     display.setCursor(1,1);
//     display.print("Sens A ");
//     display.print(baro/10, 0);
//     display.println("%");        
//     display.setCursor(1,18);
//     display.print("Sens B ");
//     display.print(sensor_b/10, 0);
//     display.println("%");  
//     // display.setTextSize(3); 
//     // display.setCursor(74,6);
//     // display.print(sensor_a/10, 0);
//     // display.println("%");         
//     display.display();


// }


///// SCREEN DRAWING FUNCTIONS /////
void dispOilPrs (Adafruit_SSD1306 *display) {
    display->setTextColor(WHITE); 
    display->clearDisplay();             //clear buffer
    display->setTextSize(2);             // text size
    display->setCursor(1,1);
    display->println("Oil");        
    display->setCursor(1,18);
    display->println("Press");
    display->setTextSize(3); 
    display->setCursor(72,6);
    display->println(oilPrs, 0);         
    display->display();
}

void dispCoolantTemp (Adafruit_SSD1306 *display) {
    display->setTextColor(WHITE); 
    display->clearDisplay();             //clear buffer
    display->setTextSize(2);             // text size
    display->setCursor(1,1);
    display->println("Eng");        
    display->setCursor(1,18);
    display->println("Temp");
    display->setTextSize(3); 
    display->setCursor(66,6);
    display->println(coolantTemp, 0);         
    display->display();
}

void dispOilTemp (Adafruit_SSD1306 *display) {
    display->setTextColor(WHITE); 
    display->clearDisplay();             //clear buffer
    display->setTextSize(2);             // text size
    display->setCursor(1,1);
    display->println("Oil");        
    display->setCursor(1,18);
    display->println("Temp");
    display->setTextSize(3); 
    display->setCursor(66,6);
    display->println(oilTemp, 0);         
    display->display();
}

void dispFuelPrs (Adafruit_SSD1306 *display) {
    display->setTextColor(WHITE); 
    display->clearDisplay();             //clear buffer
    display->setTextSize(2);             // text size
    display->setCursor(1,1);
    display->println("Fuel");        
    display->setCursor(1,18);
    display->println("Prs");
    display->setTextSize(3); 
    display->setCursor(72,6);
    display->println(fuelPrs, 0);         
    display->display();
}

void dispFuelLvl (Adafruit_SSD1306 *display) {
    display->setTextColor(WHITE); 
    display->clearDisplay();             //clear buffer
    display->setTextSize(2);             // text size
    display->setCursor(1,1);
    display->println("Fuel");        
    display->setCursor(1,18);
    display->println("Level");
    display->setTextSize(3); 
    display->setCursor(72,6);
    display->print(fuelLvl, 0);
    display->println("%");         
    display->display();
}

void dispRectangle (Adafruit_SSD1306 *display) {
    display->setTextColor(WHITE); 
    display->clearDisplay();             //clear buffer
    display->setTextSize(2);             // text size
    display->setCursor(1,1);
    display->println("TEST SCREEN");        
    display->drawRect(0,0,128,32,SSD1306_WHITE);       
    display->display();
}

void dispFalconScript(Adafruit_SSD1306 *display) {
    display->clearDisplay();             //clear buffer
    display->drawBitmap(0, 0, img_falcon_script, SCREEN_W, SCREEN_H, 1);
    display->display();
}

void dispOilPrsGfx (Adafruit_SSD1306 *display) {
    display->setTextColor(WHITE); 
    display->clearDisplay();             //clear buffer
    display->drawBitmap(0, 0, img_oilPrs, 40, 32, 1);
    display->setTextSize(3); 
    display->setCursor(72,6);
    display->println(oilPrs, 0);         
    display->display();
}

void dispCoolantTempGfx (Adafruit_SSD1306 *display) {
    display->setTextColor(WHITE); 
    display->clearDisplay();             //clear buffer
    display->drawBitmap(0, 0, img_coolantTemp, 38, 32, 1);
    display->setTextSize(3); 
    display->setCursor(66,6);
    display->println(coolantTemp, 0);         
    display->display();
}

void dispBattVoltGfx (Adafruit_SSD1306 *display) {
    display->setTextColor(WHITE); 
    display->clearDisplay();             //clear buffer
    display->drawBitmap(0, 0, img_battVolt, 35, 32, 1);
    display->setTextSize(3); 
    display->setCursor(66,6);
    display->println(battVolt, 1);         
    display->display();
}



///// CAN BUS FUNCTIONS /////

void sendCAN_200(int inputVal) //Send input value to CAN BUS at address 0x200
{
  // send data:  ID = 0x100, Standard CAN Frame, Data length = 8 bytes, 'data' = array of data bytes to send

       //BIG ENDIAN 
        data[1] = highByte(inputVal);
        data[0] = lowByte(inputVal);
//        byte sndStat = CAN0.sendMsgBuf(0x100, 0, 8, data);
        byte sndStat = CAN0.sendMsgBuf(0x200, 0, 8, data);
//        if(sndStat == CAN_OK){
//          Serial.println("Message Sent Successfully!");
//        } 
//        else {
//          Serial.println("Error Sending Message...");
//        }
}

void sendCAN_201(int inputVal) //Send input value to CAN BUS
{
        // BIG  ENDIAN
        //data[2] = highByte(inputVal);
        //data[3] = lowByte(inputVal);
        // LITTLE  ENDIAN
        data[1] = highByte(inputVal);
        data[0] = lowByte(inputVal);

        byte sndStat = CAN0.sendMsgBuf(0x201, 0, 8, data);
}

void sendCAN_202(int inputVal) //Send input value to CAN BUS
{
        // BIG  ENDIAN
        //data[2] = highByte(inputVal);
        //data[3] = lowByte(inputVal);
        // LITTLE  ENDIAN
        data[1] = highByte(inputVal);
        data[0] = lowByte(inputVal);
        byte sndStat = CAN0.sendMsgBuf(0x202, 0, 8, data);
}

void sendCAN_203(int inputVal_1, int inputVal_2, int inputVal_3, int inputVal_4) //Send input value to CAN BUS
{
        // LITTLE  ENDIAN 
        data[0] = lowByte(inputVal_1);
        data[1] = highByte(inputVal_1);
        // LITTLE  ENDIAN 
        data[2] = lowByte(inputVal_2);
        data[3] = highByte(inputVal_2);
        // LITTLE  ENDIAN 
        data[4] = lowByte(inputVal_3);
        data[5] = highByte(inputVal_3);
        // LITTLE  ENDIAN 
        data[6] = lowByte(inputVal_4);
        data[7] = highByte(inputVal_4);

        //Serial.println(inputVal_1);
        byte sndStat = CAN0.sendMsgBuf(0x203, 0, 8, data);
}

void receiveCAN ()  //Recive message from CAN BUS
{
  
    CAN0.readMsgBuf(&rxId, &len, rxBuf);      // Read data: len = data length, buf = data byte(s)
    for (byte i =0; i< len; i++){
      canMessageData[i] = rxBuf[i];
      //Serial.println(canMessageData[i]);
    }
//    if((rxId & 0x80000000) == 0x80000000)     // Determine if ID is standard (11 bits) or extended (29 bits)
//      sprintf(msgString, "Extended ID: 0x%.8lX  DLC: %1d  Data:", (rxId & 0x1FFFFFFF), len);
//    else
//      sprintf(msgString, "Standard ID: 0x%.3lX       DLC: %1d  Data:", rxId, len);
//  
//    Serial.print(msgString);
//  
//    if((rxId & 0x40000000) == 0x40000000){    // Determine if message is a remote request frame.
//      sprintf(msgString, " REMOTE REQUEST FRAME");
//      Serial.print(msgString);
//    } else {
//      for(byte i = 0; i<len; i++){
//        sprintf(msgString, " 0x%.2X", rxBuf[i]);
//        Serial.print(msgString);
//      }
////      // report value of sensor sent across CAN Bus in human readable format
////        float var = (rxBuf[0]<<8) + rxBuf[1];
////        Serial.print("Volts:");
////        Serial.println(var/100);
//    }      
//    Serial.println();
}


void parseCAN( unsigned long id, unsigned long msg)
{
  int var1 = 0;
  
  if (id == 0x200) {  //test 
    Serial.print("Address 0x200 recognized ");
    var1 = (rxBuf[2]<<8) + rxBuf[3];
    Serial.print("Speed:");
    float dispVal = var1/16;
    Serial.println(dispVal);
  }
  else if (id == 0x360){  //Haltech Protocol
    float rpmCAN = (rxBuf[0]<<8) + rxBuf[1];
    Serial.print("RPM:");
    Serial.println(rpmCAN);   // y = x

    float mapCAN = (rxBuf[2]<<8) + rxBuf[3];
    Serial.print("MAP:");
    Serial.println(mapCAN/10);   // y = x/10

    float tpsCAN = (rxBuf[4]<<8) + rxBuf[5];
    Serial.print("TPS:");
    Serial.println(tpsCAN/10);   // y = x/10
  }
  else if (id == 0x361){  //Haltech Protocol
    float fuelPrsCAN = (rxBuf[0]<<8) + rxBuf[1];
    Serial.print("FuelPressure:");
    Serial.println(fuelPrsCAN/10 - 101.3);   // y = x/10 - 101.3

    float oilPrsCAN = (rxBuf[2]<<8) + rxBuf[3];
    Serial.print("Oil Pressure:");   // y = x/10 - 101.3
    Serial.println(oilPrsCAN/10 - 101.3); 
  }
  else if (id == 0x362){  //Haltech Protocol
    float injDutyCAN = (rxBuf[0]<<8) + rxBuf[1];
    Serial.print("Injector DC:");
    Serial.println(injDutyCAN/10);   // y = x/10

    float ignAngCAN = (rxBuf[4]<<8) + rxBuf[5];
    Serial.print("Ignition Angle:");   // y = x/10
    Serial.println(ignAngCAN/10); 
  }
  else if (id == 0x368){  //Haltech Protocol
    float afr1CAN = (rxBuf[0]<<8) + rxBuf[1];
    Serial.print("AFR:");
    Serial.println(afr1CAN/1000);   // y = x/1000
  }
  else if (id == 0x368){  //Haltech Protocol
    float knockCAN = (rxBuf[0]<<8) + rxBuf[1];
    Serial.print("Knock Level:");
    Serial.println(knockCAN/100);   // y = x/100
  }
  else if (id == 0x3E0){  //Haltech Protocol
    float coolantTempCAN = (rxBuf[0]<<8) + rxBuf[1];
    Serial.print("Coolant Temp:");
    Serial.println(coolantTempCAN/10);   // y = x/10

    float airTempCAN = (rxBuf[2]<<8) + rxBuf[3];
    Serial.print("IAT:");
    Serial.println(airTempCAN/10);   // y = x/10

    float fuelTempCAN = (rxBuf[4]<<8) + rxBuf[5];
    Serial.print("Fuel Temp:");
    Serial.println(fuelTempCAN/10);   // y = x/10

    float oilTempCAN = (rxBuf[6]<<8) + rxBuf[7];
    Serial.print("Oil Temp:");
    Serial.println(oilTempCAN/10);   // y = x/10
  }
  else if (id == 0x3E1){  //Haltech Protocol
    float transTempCAN = (rxBuf[0]<<8) + rxBuf[1];
    Serial.print("Trans Temp:");
    Serial.println(transTempCAN/10);   // y = x/10

    float fuelCompCAN = (rxBuf[4]<<8) + rxBuf[5];
    Serial.print("Ethanol %:");
    Serial.println(fuelCompCAN/10);   // y = x/10
  }

  
}
